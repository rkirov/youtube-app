System.register(["rtts_assert/rtts_assert", "angular2/test_lib", "angular2/src/dom/dom_adapter", "angular2/change_detection", "angular2/src/core/compiler/compiler", "angular2/src/core/compiler/directive_metadata_reader", "angular2/src/core/compiler/shadow_dom_strategy", "angular2/src/core/compiler/template_loader", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/url_resolver", "angular2/src/core/compiler/style_url_resolver", "angular2/src/core/compiler/css_processor", "angular2/src/core/events/event_manager", "angular2/src/core/zone/vm_turn_zone", "angular2/src/mock/template_resolver_mock", "angular2/di", "angular2/angular2", "angular2/forms"], function($__export) {
  "use strict";
  var assert,
      afterEach,
      AsyncTestCompleter,
      beforeEach,
      ddescribe,
      describe,
      dispatchEvent,
      el,
      expect,
      iit,
      inject,
      it,
      queryView,
      xit,
      DOM,
      Lexer,
      Parser,
      ChangeDetector,
      dynamicChangeDetection,
      Compiler,
      CompilerCache,
      DirectiveMetadataReader,
      NativeShadowDomStrategy,
      TemplateLoader,
      ComponentUrlMapper,
      UrlResolver,
      StyleUrlResolver,
      CssProcessor,
      EventManager,
      DomEventsPlugin,
      VmTurnZone,
      MockTemplateResolver,
      Injector,
      Component,
      Decorator,
      Template,
      PropertySetter,
      ControlGroupDirective,
      ControlDirective,
      Control,
      ControlGroup,
      OptionalControl,
      ControlValueAccessor,
      RequiredValidatorDirective,
      CheckboxControlValueAccessor,
      DefaultValueAccessor,
      Validators,
      MyComp,
      WrappedValue,
      FakeVmTurnZone;
  function main() {
    function detectChanges(view) {
      view.changeDetector.detectChanges();
    }
    function compile(componentType, template, context, callback) {
      var tplResolver = new MockTemplateResolver();
      var urlResolver = new UrlResolver();
      var compiler = new Compiler(dynamicChangeDetection, new TemplateLoader(null, null), new DirectiveMetadataReader(), new Parser(new Lexer()), new CompilerCache(), new NativeShadowDomStrategy(new StyleUrlResolver(urlResolver)), tplResolver, new ComponentUrlMapper(), urlResolver, new CssProcessor(null));
      tplResolver.setTemplate(componentType, new Template({
        inline: template,
        directives: [ControlGroupDirective, ControlDirective, WrappedValue, RequiredValidatorDirective, CheckboxControlValueAccessor, DefaultValueAccessor]
      }));
      compiler.compile(componentType).then((function(pv) {
        var eventManager = new EventManager([new DomEventsPlugin()], new FakeVmTurnZone());
        var view = pv.instantiate(null, eventManager);
        view.hydrate(new Injector([]), null, null, context, null);
        detectChanges(view);
        callback(view);
      }));
    }
    if (DOM.supportsDOMEvents()) {
      describe("integration tests", (function() {
        it("should initialize DOM elements with the given form object", inject([AsyncTestCompleter], (function(async) {
          var ctx = new MyComp(new ControlGroup({"login": new Control("loginValue")}));
          var t = "<div [control-group]=\"form\">\n                <input type=\"text\" control=\"login\">\n              </div>";
          compile(MyComp, t, ctx, (function(view) {
            var input = queryView(view, "input");
            expect(input.value).toEqual("loginValue");
            async.done();
          }));
        })));
        it("should update the control group values on DOM change", inject([AsyncTestCompleter], (function(async) {
          var form = new ControlGroup({"login": new Control("oldValue")});
          var ctx = new MyComp(form);
          var t = "<div [control-group]=\"form\">\n                  <input type=\"text\" control=\"login\">\n                </div>";
          compile(MyComp, t, ctx, (function(view) {
            var input = queryView(view, "input");
            input.value = "updatedValue";
            dispatchEvent(input, "change");
            expect(form.value).toEqual({"login": "updatedValue"});
            async.done();
          }));
        })));
        it("should update DOM elements when rebinding the control group", inject([AsyncTestCompleter], (function(async) {
          var form = new ControlGroup({"login": new Control("oldValue")});
          var ctx = new MyComp(form);
          var t = "<div [control-group]=\"form\">\n                <input type=\"text\" control=\"login\">\n              </div>";
          compile(MyComp, t, ctx, (function(view) {
            ctx.form = new ControlGroup({"login": new Control("newValue")});
            detectChanges(view);
            var input = queryView(view, "input");
            expect(input.value).toEqual("newValue");
            async.done();
          }));
        })));
        it("should update DOM element when rebinding the control name", inject([AsyncTestCompleter], (function(async) {
          var ctx = new MyComp(new ControlGroup({
            "one": new Control("one"),
            "two": new Control("two")
          }), "one");
          var t = "<div [control-group]=\"form\">\n                <input type=\"text\" [control]=\"name\">\n              </div>";
          compile(MyComp, t, ctx, (function(view) {
            var input = queryView(view, "input");
            expect(input.value).toEqual("one");
            ctx.name = "two";
            detectChanges(view);
            expect(input.value).toEqual("two");
            async.done();
          }));
        })));
        describe("different control types", (function() {
          it("should support <input type=text>", inject([AsyncTestCompleter], (function(async) {
            var ctx = new MyComp(new ControlGroup({"text": new Control("old")}));
            var t = "<div [control-group]=\"form\">\n                    <input type=\"text\" control=\"text\">\n                  </div>";
            compile(MyComp, t, ctx, (function(view) {
              var input = queryView(view, "input");
              expect(input.value).toEqual("old");
              input.value = "new";
              dispatchEvent(input, "input");
              expect(ctx.form.value).toEqual({"text": "new"});
              async.done();
            }));
          })));
          it("should support <input> without type", inject([AsyncTestCompleter], (function(async) {
            var ctx = new MyComp(new ControlGroup({"text": new Control("old")}));
            var t = "<div [control-group]=\"form\">\n                    <input control=\"text\">\n                  </div>";
            compile(MyComp, t, ctx, (function(view) {
              var input = queryView(view, "input");
              expect(input.value).toEqual("old");
              input.value = "new";
              dispatchEvent(input, "input");
              expect(ctx.form.value).toEqual({"text": "new"});
              async.done();
            }));
          })));
          it("should support <textarea>", inject([AsyncTestCompleter], (function(async) {
            var ctx = new MyComp(new ControlGroup({"text": new Control('old')}));
            var t = "<div [control-group]=\"form\">\n                    <textarea control=\"text\"></textarea>\n                  </div>";
            compile(MyComp, t, ctx, (function(view) {
              var textarea = queryView(view, "textarea");
              expect(textarea.value).toEqual("old");
              textarea.value = "new";
              dispatchEvent(textarea, "input");
              expect(ctx.form.value).toEqual({"text": 'new'});
              async.done();
            }));
          })));
          it("should support <type=checkbox>", inject([AsyncTestCompleter], (function(async) {
            var ctx = new MyComp(new ControlGroup({"checkbox": new Control(true)}));
            var t = "<div [control-group]=\"form\">\n                    <input type=\"checkbox\" control=\"checkbox\">\n                  </div>";
            compile(MyComp, t, ctx, (function(view) {
              var input = queryView(view, "input");
              expect(input.checked).toBe(true);
              input.checked = false;
              dispatchEvent(input, "change");
              expect(ctx.form.value).toEqual({"checkbox": false});
              async.done();
            }));
          })));
          it("should support <select>", inject([AsyncTestCompleter], (function(async) {
            var ctx = new MyComp(new ControlGroup({"city": new Control("SF")}));
            var t = "<div [control-group]=\"form\">\n                      <select control=\"city\">\n                        <option value=\"SF\"></option>\n                        <option value=\"NYC\"></option>\n                      </select>\n                    </div>";
            compile(MyComp, t, ctx, (function(view) {
              var select = queryView(view, "select");
              var sfOption = queryView(view, "option");
              expect(select.value).toEqual('SF');
              expect(sfOption.selected).toBe(true);
              select.value = 'NYC';
              dispatchEvent(select, "change");
              expect(ctx.form.value).toEqual({"city": 'NYC'});
              expect(sfOption.selected).toBe(false);
              async.done();
            }));
          })));
          it("should support custom value accessors", inject([AsyncTestCompleter], (function(async) {
            var ctx = new MyComp(new ControlGroup({"name": new Control("aa")}));
            var t = "<div [control-group]=\"form\">\n                    <input type=\"text\" control=\"name\" wrapped-value>\n                  </div>";
            compile(MyComp, t, ctx, (function(view) {
              var input = queryView(view, "input");
              expect(input.value).toEqual("!aa!");
              input.value = "!bb!";
              dispatchEvent(input, "change");
              expect(ctx.form.value).toEqual({"name": "bb"});
              async.done();
            }));
          })));
        }));
        describe("validations", (function() {
          it("should use validators defined in html", inject([AsyncTestCompleter], (function(async) {
            var form = new ControlGroup({"login": new Control("aa")});
            var ctx = new MyComp(form);
            var t = "<div [control-group]=\"form\">\n                    <input type=\"text\" control=\"login\" required>\n                   </div>";
            compile(MyComp, t, ctx, (function(view) {
              expect(form.valid).toEqual(true);
              var input = queryView(view, "input");
              input.value = "";
              dispatchEvent(input, "change");
              expect(form.valid).toEqual(false);
              async.done();
            }));
          })));
          it("should use validators defined in the model", inject([AsyncTestCompleter], (function(async) {
            var form = new ControlGroup({"login": new Control("aa", Validators.required)});
            var ctx = new MyComp(form);
            var t = "<div [control-group]=\"form\">\n                    <input type=\"text\" control=\"login\">\n                   </div>";
            compile(MyComp, t, ctx, (function(view) {
              expect(form.valid).toEqual(true);
              var input = queryView(view, "input");
              input.value = "";
              dispatchEvent(input, "change");
              expect(form.valid).toEqual(false);
              async.done();
            }));
          })));
        }));
        describe("nested forms", (function() {
          it("should init DOM with the given form object", inject([AsyncTestCompleter], (function(async) {
            var form = new ControlGroup({"nested": new ControlGroup({"login": new Control("value")})});
            var ctx = new MyComp(form);
            var t = "<div [control-group]=\"form\">\n                    <div control-group=\"nested\">\n                      <input type=\"text\" control=\"login\">\n                    </div>\n                </div>";
            compile(MyComp, t, ctx, (function(view) {
              var input = queryView(view, "input");
              expect(input.value).toEqual("value");
              async.done();
            }));
          })));
          it("should update the control group values on DOM change", inject([AsyncTestCompleter], (function(async) {
            var form = new ControlGroup({"nested": new ControlGroup({"login": new Control("value")})});
            var ctx = new MyComp(form);
            var t = "<div [control-group]=\"form\">\n                      <div control-group=\"nested\">\n                        <input type=\"text\" control=\"login\">\n                      </div>\n                  </div>";
            compile(MyComp, t, ctx, (function(view) {
              var input = queryView(view, "input");
              input.value = "updatedValue";
              dispatchEvent(input, "change");
              expect(form.value).toEqual({"nested": {"login": "updatedValue"}});
              async.done();
            }));
          })));
        }));
      }));
    }
  }
  $__export("main", main);
  return {
    setters: [function($__m) {
      assert = $__m.assert;
    }, function($__m) {
      afterEach = $__m.afterEach;
      AsyncTestCompleter = $__m.AsyncTestCompleter;
      beforeEach = $__m.beforeEach;
      ddescribe = $__m.ddescribe;
      describe = $__m.describe;
      dispatchEvent = $__m.dispatchEvent;
      el = $__m.el;
      expect = $__m.expect;
      iit = $__m.iit;
      inject = $__m.inject;
      it = $__m.it;
      queryView = $__m.queryView;
      xit = $__m.xit;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Lexer = $__m.Lexer;
      Parser = $__m.Parser;
      ChangeDetector = $__m.ChangeDetector;
      dynamicChangeDetection = $__m.dynamicChangeDetection;
    }, function($__m) {
      Compiler = $__m.Compiler;
      CompilerCache = $__m.CompilerCache;
    }, function($__m) {
      DirectiveMetadataReader = $__m.DirectiveMetadataReader;
    }, function($__m) {
      NativeShadowDomStrategy = $__m.NativeShadowDomStrategy;
    }, function($__m) {
      TemplateLoader = $__m.TemplateLoader;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      CssProcessor = $__m.CssProcessor;
    }, function($__m) {
      EventManager = $__m.EventManager;
      DomEventsPlugin = $__m.DomEventsPlugin;
    }, function($__m) {
      VmTurnZone = $__m.VmTurnZone;
    }, function($__m) {
      MockTemplateResolver = $__m.MockTemplateResolver;
    }, function($__m) {
      Injector = $__m.Injector;
    }, function($__m) {
      Component = $__m.Component;
      Decorator = $__m.Decorator;
      Template = $__m.Template;
      PropertySetter = $__m.PropertySetter;
    }, function($__m) {
      ControlGroupDirective = $__m.ControlGroupDirective;
      ControlDirective = $__m.ControlDirective;
      Control = $__m.Control;
      ControlGroup = $__m.ControlGroup;
      OptionalControl = $__m.OptionalControl;
      ControlValueAccessor = $__m.ControlValueAccessor;
      RequiredValidatorDirective = $__m.RequiredValidatorDirective;
      CheckboxControlValueAccessor = $__m.CheckboxControlValueAccessor;
      DefaultValueAccessor = $__m.DefaultValueAccessor;
      Validators = $__m.Validators;
    }],
    execute: function() {
      MyComp = (function() {
        var MyComp = function MyComp() {
          var form = arguments[0] !== (void 0) ? arguments[0] : null;
          var name = arguments[1] !== (void 0) ? arguments[1] : null;
          this.form = form;
          this.name = name;
        };
        return ($traceurRuntime.createClass)(MyComp, {}, {});
      }());
      Object.defineProperty(MyComp, "annotations", {get: function() {
          return [new Component({selector: "my-comp"})];
        }});
      WrappedValue = (function() {
        var WrappedValue = function WrappedValue(cd, setProperty) {
          assert.argumentTypes(cd, ControlDirective, setProperty, Function);
          $traceurRuntime.superConstructor(WrappedValue).call(this);
          this._setProperty = setProperty;
          cd.valueAccessor = this;
        };
        return ($traceurRuntime.createClass)(WrappedValue, {
          writeValue: function(value) {
            this._setProperty(("!" + value + "!"));
          },
          handleOnChange: function(value) {
            this.onChange(value.substring(1, value.length - 1));
          }
        }, {});
      }());
      Object.defineProperty(WrappedValue, "annotations", {get: function() {
          return [new Decorator({
            selector: '[wrapped-value]',
            events: {'change': 'handleOnChange($event.target.value)'}
          })];
        }});
      Object.defineProperty(WrappedValue, "parameters", {get: function() {
          return [[ControlDirective], [Function, new PropertySetter('value')]];
        }});
      FakeVmTurnZone = (function($__super) {
        var FakeVmTurnZone = function FakeVmTurnZone() {
          $traceurRuntime.superConstructor(FakeVmTurnZone).call(this, {enableLongStackTrace: false});
        };
        return ($traceurRuntime.createClass)(FakeVmTurnZone, {
          run: function(fn) {
            fn();
          },
          runOutsideAngular: function(fn) {
            fn();
          }
        }, {}, $__super);
      }(VmTurnZone));
    }
  };
});

//# sourceMappingURL=angular2/test/forms/integration_spec.map

//# sourceMappingURL=../../../angular2/test/forms/integration_spec.js.map